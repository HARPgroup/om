dat$impoundment_lake_elev,
col='red',
lwd=2,
type='l'
)
points(as.POSIXct(dat$timestamp[dat$impoundment_its>500&dat$impoundment_riser_head>0]),dat$impoundment_lake_elev[dat$impoundment_its>500&dat$impoundment_riser_head>0])
#Load in a stage storage table and input orifice height, diameter, and normal stage
SS<-read.csv("C:/Users/connorb5/Desktop/GitHub/om/analysis/R/examples/SS.csv")
diameter<-8.95
height<-2
NS<-7.406753
dt<-3600
#Load in inflow data (as well as other model data)
fxn_locations = 'C:/Users/connorb5/Desktop/GitHub/r-dh-ecohydro/Analysis'
source(paste(fxn_locations,"fn_vahydro-1.0.R", sep = "/"))
source(paste(fxn_locations,"fn_iha.R", sep = "/"))
runid<-7999
elid<-340298
dat<-fn_get_runfile(elid, runid)
dat<-dat[order(as.POSIXct(dat$timestamp)),]
S<-dat$impoundment_Storage[1]#Input base storage
#Function to calculate flow from weir stage of our orifice
weir<-function(head,diameter=d){
riser_flow<-3.1*diameter*head^1.5
return(riser_flow)
}
#Function to calculate flow from pipe stage of our orifice
pipe<-function(head,diameter=d,height=h){
riser_flow<-0.6*height*diameter*sqrt(2*32.2*(head-0.5*height))
return(riser_flow)
}
#Function to calculate outflow based on stage and normal pool elevation
discharge<-function(stage){
head<-stage-NS
if(head<0){
riser_flow<-0
} else if (head>0&head<height){
riser_flow<-weir(head,diameter)
} else if (head>0&head>=height){
riser_flow<-pipe(head,diameter,height)
} else {
riser_flow<-0
}
return(riser_flow)
}
#Function to calculate discharge from a given storage
Solver<-function(Storage){
Stg<-approx(x=SS$Storage,y=SS$Stage,xout=Storage,rule=1)$y
riser_flow<-discharge(Stg)
return(riser_flow)
}
#Create empty columns to store data. initialize with above boundary conditions
dat$MPMStorage<-numeric(length(dat$impoundment_Qin));dat$MPMStorage[1]<-S
dat$MPMQout<-numeric(length(dat$impoundment_Qin))
dat$MPMStage<-numeric(length(dat$impoundment_Qin));dat$MPMStage[1]<-approx(x=SS$Storage,y=SS$Stage,xout=S,rule=1)$y;
dat$its<-numeric(length(dat$impoundment_Qin))
#loop that looks at each inflow and calculates storage and outflow simealtaneously by creating a function to
#find S such that dS=Qin-Qout (MPM equation)
for (i in 2:length(dat$impoundment_Qin)){
S0<-dat$MPMStorage[i-1]#Stores previous timestep storage for easy reference
Qin<-as.numeric(dat$impoundment_Qin[i])#Stores inflow for easy reference
S1<-S0+(Qin*3600/43560)#Maximum possible storage
riser_flow<-Solver(S1)#Maximum possible outflow
riserP<-riser_flow#Maximum interval outflow for use in bisection method
Si<-0#Minimuim storage for use in bisection method
Sn<-S1#A storage to be iterated within the below while loop
#Begin a loop that continuously computes the MPM equation until tolerance is achieved
x<-1
while (abs((Sn-S0+riser_flow*dt/43560)-(Qin*dt/43560)) > 0.0001){
x<-x+1
#Check the conditional statement in the while loop to break the loop before computation
if (x>500){
Sn<-S0
riser_flow<-Qin
break
}
if (abs((Sn-S0+riser_flow*dt/43560)-(Qin*dt/43560)) > 0.0001){
#If tolerance has not been achieved, use the bisection method to find S and Q
Sn<-(S1+Si)/2#New storage computed from the midpoint of max and min storage, S1 and Si respectivley
riser_flow<-Solver(Sn)#Corresponding outflow
#Now that flow has been calculated, the bisection method can be continued. Need to shorten interval with guess Sn
#Compute the MPM equation for S1 (maximum storage) and Sn (current iterator). If product is negative, they are of
#opposite sign. Thus, a solution for S and Q are contained within this new interval, replace Si with Sn. Otherwise,
#if they are of the same sign, assign Sn as S1 to serve as the new maximum storage value. Then replace riserP with
#the current riser_flow for future reference in solving the MPM for S1
if(((Sn-S0+riser_flow*dt/43560)-(Qin*dt/43560))*((S1-S0+riserP*dt/43560)-(Qin*dt/43560))<0){
Si<-Sn
} else {
S1<-Sn
riserP<-riser_flow
}
} else {
#Tolerance achieved, solution found
break
}
}
#Store stage, storage, and outflow calculated from the MPM method for plotting
dat$MPMStorage[i]<-Sn
dat$MPMQout[i]<-riser_flow
dat$MPMStage[i]<-approx(x=SS$Storage,y=SS$Stage,xout=S1,rule=1)$y
dat$its[i]<-x
}
par(mar=c(5,6,2,4))
plot(
as.POSIXct(dat$timestamp),
as.numeric(dat$MPMStage),
type='l',
col='blue',
lwd=2,
cex.lab=2,
cex.axis=2,
#ylim=c(0,200),
xlab='Time',
ylab='Stage (ft)'
)
lines(
as.POSIXct(dat$timestamp),
dat$impoundment_lake_elev,
col='red',
lwd=2,
type='l'
)
points(as.POSIXct(dat$timestamp[dat$impoundment_its>500&dat$impoundment_riser_head>0]),dat$impoundment_lake_elev[dat$impoundment_its>500&dat$impoundment_riser_head>0])
legend(x=5250,y=9.25,c('MPM','VA Hydro'),col=c('blue','red'),lwd=2,pch=1,cex=2,bty='n',y.intersp = 0.5)
par(mar=c(5,6,2,4))
plot(
as.POSIXct(dat$timestamp),
as.numeric(dat$MPMStage),
type='l',
col='blue',
lwd=2,
cex.lab=2,
cex.axis=2,
#ylim=c(0,200),
xlab='Time',
ylab='Stage (ft)'
xlim=c(min(dat$impoundment_lake_elev),max(dat$impoundment_lake_elev))
)
c(min(dat$impoundment_lake_elev),max(dat$impoundment_lake_elev))
par(mar=c(5,6,2,4))
plot(
as.POSIXct(dat$timestamp),
as.numeric(dat$MPMStage),
type='l',
col='blue',
lwd=2,
cex.lab=2,
cex.axis=2,
#ylim=c(0,200),
xlab='Time',
ylab='Stage (ft)',
xlim=c(min(dat$impoundment_lake_elev),max(dat$impoundment_lake_elev))
)
par(mar=c(5,6,2,4))
plot(
as.POSIXct(dat$timestamp),
as.numeric(dat$MPMStage),
type='l',
col='blue',
lwd=2,
cex.lab=2,
cex.axis=2,
#ylim=c(0,200),
xlab='Time',
ylab='Stage (ft)',
ylim=c(min(dat$impoundment_lake_elev),max(dat$impoundment_lake_elev))
)
lines(
as.POSIXct(dat$timestamp),
dat$impoundment_lake_elev,
col='red',
lwd=2,
type='l'
)
points(as.POSIXct(dat$timestamp[dat$impoundment_its>500&dat$impoundment_riser_head>0]),dat$impoundment_lake_elev[dat$impoundment_its>500&dat$impoundment_riser_head>0])
par(new=T)
plot(dat$timestamp,dat$impoundment_Qin,type='l',lty=3,ann=F,axes=F)
View(dat)
library(dplyr)
library(rgdal)
library(rgeos)
library(raster)
plus<-function(x){
if(all(is.na(x))){
c(NA)
}else{
sum(x,na.rm = TRUE)}
}
ECHOCRS<-'+proj=longlat +ellps=GRS80 +datum=NAD83 +no_defs'
VA<-readOGR('G:\\My Drive\\HARP\\impoundment_evap_HARP-2016\\EvapInputs.gdb',layer="VA")
VA<-spTransform(VA,CRS=ECHOCRS)
HUC10<-readOGR("G:/My Drive/GIS/HUC.gdb",layer='WBDHU10')
HUC10<-spTransform(HUC10,CRS=ECHOCRS)
HUC10Cl<-gIntersection(HUC10,VA,id=as.character(HUC10@data$HUC10),byid=TRUE,drop_lower_td=TRUE)
HUC10Overlay<-HUC10
HUC10Overlay@data<-HUC10Overlay@data[,c(11,12)]
names(HUC10Overlay@data)<-c("HUC10","HUC10Name")
a<-read.csv("G:/My Drive/USGS_ConsumptiveUse/Spring Semester, 2018/Connor/USGS Testing/2016 ECHO/FacTableMedNoDis2016.csv")
a<-a[!(is.na(a$lat)&is.na(a$lon)),]
a<-SpatialPointsDataFrame(data.frame(lon=a$lon,lat=a$lat),a,proj4string = CRS(ECHOCRS))
a@data$FacilityName<-as.character(a@data$FacilityName)
a@data$Flow.MK_plus<-as.numeric(as.character(a@data$Flow.MK_plus))
FacHUC<-over(a,HUC10Overlay)
a@data$HUC10<-FacHUC$HUC10
a@data$HUC10Name<-FacHUC$HUC10Name
c<-as.data.frame(a@data %>% group_by(HUC10Name) %>% summarize(Discharge=plus(Flow.MK_plus)))
b<-read.csv("G:/My Drive/USGS_ConsumptiveUse/Spring Semester, 2018/Connor/USGS Testing/vahydro_2016FacTable.csv")
b<-b[!(is.na(b$Lat)&is.na(b$Long)),]
b<-SpatialPointsDataFrame(data.frame(lon=b$Long,lat=b$Lat),b,proj4string = CRS('+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs'))
b<-spTransform(b,ECHOCRS)
b@data$Sum<-as.numeric(b@data$Sum)
VAHydHUC<-over(b,HUC10Overlay)
b@data$HUC10<-VAHydHUC$HUC10
b@data$HUC10Name<-VAHydHUC$HUC10Name
d<-as.data.frame(b@data %>% group_by(HUC10Name) %>% summarize(Withdraw=plus(Sum)))
d$HUC10Name<-as.character(d$HUC10Name);c$HUC10Name<-as.character(c$HUC10Name)
a@data$discharge<-a$Flow.MK_plus
for (i in 1:length(a@data$SourceData)){
if(!is.na(a@data$Flow.MK_plus[i])&!is.na(a@data$DesFlow[i])){
if(a@data$Flow.MK_plus[i]>a@data$DesFlow[i]){
a@data$discharge[i]<-a@data$DesFlow[i]
}
}
}
c<-as.data.frame(a@data %>% group_by(HUC10Name) %>% summarize(Discharge=plus(discharge)))
for (i in 1:length(HUC10@data$HUC10)){
HUC10@data$Withdraw[i]<-d$Withdraw[d$HUC10Name==HUC10@data$Name[i]][1]/365
HUC10@data$Discharge[i]<-c$Discharge[c$HUC10Name==HUC10@data$Name[i]][1]
}
HUC10@data$Use<-HUC10@data$Withdraw-HUC10@data$Discharge
for (i in 1:length(HUC10@data$TNMID)){
if(!is.na(HUC10@data$Use[i])){
if(HUC10@data$Use[i]<(-100)){
HUC10@data$UseClass[i]<-5
HUC10@data$Color[i]<-"red"
}else if(HUC10@data$Use[i]<(-10)){
HUC10@data$UseClass[i]<-4
HUC10@data$Color[i]<-"orange"
}else if(HUC10@data$Use[i]<(-1)){
HUC10@data$UseClass[i]<-3
HUC10@data$Color[i]<-"green"
}else if(HUC10@data$Use[i]<0){
HUC10@data$UseClass[i]<-2
HUC10@data$Color[i]<-"cyan"
}else{
HUC10@data$UseClass[i]<-1
HUC10@data$Color[i]<-"black"
}
}
}
HUC10Cl<-gIntersection(HUC10,VA,id=as.character(HUC10@data$HUC10),byid=TRUE,drop_lower_td=TRUE)
HUC10Cl<-SpatialPolygonsDataFrame(HUC10Cl,HUC10@data[as.character(HUC10@data$HUC10)%in%names(HUC10Cl),],match.ID = "HUC10")
plot(HUC10Cl,col=HUC10Cl@data$Color,axes=T,cex.axis=2)
lines(HUC10Cl,col='light grey')
legend(-84, 39.75, c("< -100", "-100 - -10", "-10 - -1", "-1 - 0","0 +"),
col =c("red","orange","green","cyan","black"), pch=15,pt.cex=4,lty=0,bty='n',y.intersp = 0.25,
x.intersp = 0.25,cex=2,lwd=2,seg.len=0.25)
sum(HUC10Cl$Discharge,na.rm=T);sum(HUC10Cl$Withdraw,na.rm=T)
legend(-84, 39.75, c("< -100 MGD", "-100 - -10 MGD", "-10 - -1 MGD", "-1 - 0 MGD","0 + MGD"),
col =c("red","orange","green","cyan","black"), pch=15,pt.cex=4,lty=0,bty='n',y.intersp = 0.25,
x.intersp = 0.25,cex=2,lwd=2,seg.len=0.25)
ECHOCRS<-'+proj=longlat +ellps=GRS80 +datum=NAD83 +no_defs'
VA<-readOGR('G:\\My Drive\\HARP\\impoundment_evap_HARP-2016\\EvapInputs.gdb',layer="VA")
VA<-spTransform(VA,CRS=ECHOCRS)
HUC10<-readOGR("G:/My Drive/GIS/HUC.gdb",layer='WBDHU10')
HUC10<-spTransform(HUC10,CRS=ECHOCRS)
HUC10Cl<-gIntersection(HUC10,VA,id=as.character(HUC10@data$HUC10),byid=TRUE,drop_lower_td=TRUE)
HUC10Overlay<-HUC10
HUC10Overlay@data<-HUC10Overlay@data[,c(11,12)]
names(HUC10Overlay@data)<-c("HUC10","HUC10Name")
a<-read.csv("G:/My Drive/USGS_ConsumptiveUse/Spring Semester, 2018/Connor/USGS Testing/2016 ECHO/FacTableMedNoDis2016.csv")
a<-a[!(is.na(a$lat)&is.na(a$lon)),]
a<-SpatialPointsDataFrame(data.frame(lon=a$lon,lat=a$lat),a,proj4string = CRS(ECHOCRS))
a@data$FacilityName<-as.character(a@data$FacilityName)
a@data$Flow.MK_plus<-as.numeric(as.character(a@data$Flow.MK_plus))
FacHUC<-over(a,HUC10Overlay)
a@data$HUC10<-FacHUC$HUC10
a@data$HUC10Name<-FacHUC$HUC10Name
c<-as.data.frame(a@data %>% group_by(HUC10Name) %>% summarize(Discharge=plus(Flow.MK_plus)))
b<-read.csv("G:/My Drive/USGS_ConsumptiveUse/Spring Semester, 2018/Connor/USGS Testing/vahydro_2016FacTable.csv")
b<-b[!(is.na(b$Lat)&is.na(b$Long)),]
b<-SpatialPointsDataFrame(data.frame(lon=b$Long,lat=b$Lat),b,proj4string = CRS('+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs'))
b<-spTransform(b,ECHOCRS)
b@data$Sum<-as.numeric(b@data$Sum)
VAHydHUC<-over(b,HUC10Overlay)
b@data$HUC10<-VAHydHUC$HUC10
b@data$HUC10Name<-VAHydHUC$HUC10Name
d<-as.data.frame(b@data %>% group_by(HUC10Name) %>% summarize(Withdraw=plus(Sum)))
d$HUC10Name<-as.character(d$HUC10Name);c$HUC10Name<-as.character(c$HUC10Name)
for (i in 1:length(HUC10@data$HUC10)){
HUC10@data$Withdraw[i]<-d$Withdraw[d$HUC10Name==HUC10@data$Name[i]][1]/365
HUC10@data$Discharge[i]<-c$Discharge[c$HUC10Name==HUC10@data$Name[i]][1]
}
HUC10@data$Use<-HUC10@data$Withdraw-HUC10@data$Discharge
for (i in 1:length(HUC10@data$TNMID)){
if(!is.na(HUC10@data$Use[i])){
if(HUC10@data$Use[i]<(-100)){
HUC10@data$UseClass[i]<-5
HUC10@data$Color[i]<-"red"
}else if(HUC10@data$Use[i]<(-10)){
HUC10@data$UseClass[i]<-4
HUC10@data$Color[i]<-"orange"
}else if(HUC10@data$Use[i]<(-1)){
HUC10@data$UseClass[i]<-3
HUC10@data$Color[i]<-"green"
}else if(HUC10@data$Use[i]<0){
HUC10@data$UseClass[i]<-2
HUC10@data$Color[i]<-"cyan"
}else{
HUC10@data$UseClass[i]<-1
HUC10@data$Color[i]<-"black"
}
}
}
HUC10Cl<-gIntersection(HUC10,VA,id=as.character(HUC10@data$HUC10),byid=TRUE,drop_lower_td=TRUE)
HUC10Cl<-SpatialPolygonsDataFrame(HUC10Cl,HUC10@data[as.character(HUC10@data$HUC10)%in%names(HUC10Cl),],match.ID = "HUC10")
plot(HUC10Cl,col=HUC10Cl@data$Color,axes=T,cex.axis=2)
lines(HUC10Cl,col='light grey')
legend(-84, 39.75, c("< -100 MGD", "-100 - -10 MGD", "-10 - -1 MGD", "-1 - 0 MGD","0 + MGD"),
col =c("red","orange","green","cyan","black"), pch=15,pt.cex=4,lty=0,bty='n',y.intersp = 0.25,
x.intersp = 0.25,cex=2,lwd=2,seg.len=0.25)
sum(HUC10Cl$Discharge,na.rm=T);sum(HUC10Cl$Withdraw,na.rm=T)
ECHOCRS<-'+proj=longlat +ellps=GRS80 +datum=NAD83 +no_defs'
VA<-readOGR('G:\\My Drive\\HARP\\impoundment_evap_HARP-2016\\EvapInputs.gdb',layer="VA")
VA<-spTransform(VA,CRS=ECHOCRS)
HUC10<-readOGR("G:/My Drive/GIS/HUC.gdb",layer='WBDHU10')
HUC10<-spTransform(HUC10,CRS=ECHOCRS)
HUC10Cl<-gIntersection(HUC10,VA,id=as.character(HUC10@data$HUC10),byid=TRUE,drop_lower_td=TRUE)
HUC10Overlay<-HUC10
HUC10Overlay@data<-HUC10Overlay@data[,c(11,12)]
names(HUC10Overlay@data)<-c("HUC10","HUC10Name")
a<-read.csv("G:/My Drive/USGS_ConsumptiveUse/Spring Semester, 2018/Connor/USGS Testing/2016 ECHO/FacTableMedNoDis2016.csv")
a<-a[!(is.na(a$lat)&is.na(a$lon)),]
a<-SpatialPointsDataFrame(data.frame(lon=a$lon,lat=a$lat),a,proj4string = CRS(ECHOCRS))
a@data$FacilityName<-as.character(a@data$FacilityName)
a@data$Flow.MK_plus<-as.numeric(as.character(a@data$Flow.MK_plus))
FacHUC<-over(a,HUC10Overlay)
a@data$HUC10<-FacHUC$HUC10
a@data$HUC10Name<-FacHUC$HUC10Name
c<-as.data.frame(a@data %>% group_by(HUC10Name) %>% summarize(Discharge=plus(Flow.MK_plus)))
b<-read.csv("G:/My Drive/USGS_ConsumptiveUse/Spring Semester, 2018/Connor/USGS Testing/vahydro_2016FacTable.csv")
b<-b[!(is.na(b$Lat)&is.na(b$Long)),]
b<-SpatialPointsDataFrame(data.frame(lon=b$Long,lat=b$Lat),b,proj4string = CRS('+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs'))
b<-spTransform(b,ECHOCRS)
b@data$Sum<-as.numeric(b@data$Sum)
VAHydHUC<-over(b,HUC10Overlay)
b@data$HUC10<-VAHydHUC$HUC10
b@data$HUC10Name<-VAHydHUC$HUC10Name
d<-as.data.frame(b@data %>% group_by(HUC10Name) %>% summarize(Withdraw=plus(Sum)))
d$HUC10Name<-as.character(d$HUC10Name);c$HUC10Name<-as.character(c$HUC10Name)
a@data$discharge<-a$Flow.MK_plus
for (i in 1:length(a@data$SourceData)){
if(!is.na(a@data$Flow.MK_plus[i])&!is.na(a@data$DesFlow[i])){
if(a@data$Flow.MK_plus[i]>a@data$DesFlow[i]){
a@data$discharge[i]<-a@data$DesFlow[i]
}
}
}
c<-as.data.frame(a@data %>% group_by(HUC10Name) %>% summarize(Discharge=plus(discharge)))
for (i in 1:length(HUC10@data$HUC10)){
HUC10@data$Withdraw[i]<-d$Withdraw[d$HUC10Name==HUC10@data$Name[i]][1]/365
HUC10@data$Discharge[i]<-c$Discharge[c$HUC10Name==HUC10@data$Name[i]][1]
}
HUC10@data$Use<-HUC10@data$Withdraw-HUC10@data$Discharge
for (i in 1:length(HUC10@data$TNMID)){
if(!is.na(HUC10@data$Use[i])){
if(HUC10@data$Use[i]<(-100)){
HUC10@data$UseClass[i]<-5
HUC10@data$Color[i]<-"red"
}else if(HUC10@data$Use[i]<(-10)){
HUC10@data$UseClass[i]<-4
HUC10@data$Color[i]<-"orange"
}else if(HUC10@data$Use[i]<(-1)){
HUC10@data$UseClass[i]<-3
HUC10@data$Color[i]<-"green"
}else if(HUC10@data$Use[i]<0){
HUC10@data$UseClass[i]<-2
HUC10@data$Color[i]<-"cyan"
}else{
HUC10@data$UseClass[i]<-1
HUC10@data$Color[i]<-"black"
}
}
}
HUC10Cl<-gIntersection(HUC10,VA,id=as.character(HUC10@data$HUC10),byid=TRUE,drop_lower_td=TRUE)
HUC10Cl<-SpatialPolygonsDataFrame(HUC10Cl,HUC10@data[as.character(HUC10@data$HUC10)%in%names(HUC10Cl),],match.ID = "HUC10")
plot(HUC10Cl,col=HUC10Cl@data$Color,axes=T,cex.axis=2)
lines(HUC10Cl,col='light grey')
legend(-84, 39.75, c("< -100 MGD", "-100 - -10 MGD", "-10 - -1 MGD", "-1 - 0 MGD","0 + MGD"),
col =c("red","orange","green","cyan","black"), pch=15,pt.cex=4,lty=0,bty='n',y.intersp = 0.25,
x.intersp = 0.25,cex=2,lwd=2,seg.len=0.25)
sum(HUC10Cl$Discharge,na.rm=T);sum(HUC10Cl$Withdraw,na.rm=T)
#Load in a stage storage table and input orifice height, diameter, and normal stage
SS<-read.csv("C:/Users/connorb5/Desktop/GitHub/om/analysis/R/examples/SS.csv")
diameter<-8.95
height<-2
NS<-7.406753
dt<-3600
#Load in inflow data (as well as other model data)
fxn_locations = 'C:/Users/connorb5/Desktop/GitHub/r-dh-ecohydro/Analysis'
source(paste(fxn_locations,"fn_vahydro-1.0.R", sep = "/"))
source(paste(fxn_locations,"fn_iha.R", sep = "/"))
runid<-7999
elid<-340298
dat<-fn_get_runfile(elid, runid)
dat<-dat[order(as.POSIXct(dat$timestamp)),]
S<-dat$impoundment_Storage[1]#Input base storage
#Function to calculate flow from weir stage of our orifice
weir<-function(head,diameter=d){
riser_flow<-3.1*diameter*head^1.5
return(riser_flow)
}
#Function to calculate flow from pipe stage of our orifice
pipe<-function(head,diameter=d,height=h){
riser_flow<-0.6*height*diameter*sqrt(2*32.2*(head-0.5*height))
return(riser_flow)
}
#Function to calculate outflow based on stage and normal pool elevation
discharge<-function(stage){
head<-stage-NS
if(head<0){
riser_flow<-0
} else if (head>0&head<height){
riser_flow<-weir(head,diameter)
} else if (head>0&head>=height){
riser_flow<-pipe(head,diameter,height)
} else {
riser_flow<-0
}
return(riser_flow)
}
#Function to calculate discharge from a given storage
Solver<-function(Storage){
Stg<-approx(x=SS$Storage,y=SS$Stage,xout=Storage,rule=1)$y
riser_flow<-discharge(Stg)
return(riser_flow)
}
#Create empty columns to store data. initialize with above boundary conditions
dat$MPMStorage<-numeric(length(dat$impoundment_Qin));dat$MPMStorage[1]<-S
dat$MPMQout<-numeric(length(dat$impoundment_Qin))
dat$MPMStage<-numeric(length(dat$impoundment_Qin));dat$MPMStage[1]<-approx(x=SS$Storage,y=SS$Stage,xout=S,rule=1)$y;
dat$its<-numeric(length(dat$impoundment_Qin))
#loop that looks at each inflow and calculates storage and outflow simealtaneously by creating a function to
#find S such that dS=Qin-Qout (MPM equation)
for (i in 2:length(dat$impoundment_Qin)){
S0<-dat$MPMStorage[i-1]#Stores previous timestep storage for easy reference
Qin<-as.numeric(dat$impoundment_Qin[i])#Stores inflow for easy reference
S1<-S0+(Qin*3600/43560)#Maximum possible storage
riser_flow<-Solver(S1)#Maximum possible outflow
riserP<-riser_flow#Maximum interval outflow for use in bisection method
Si<-0#Minimuim storage for use in bisection method
Sn<-S1#A storage to be iterated within the below while loop
#Begin a loop that continuously computes the MPM equation until tolerance is achieved
x<-1
while (abs((Sn-S0+riser_flow*dt/43560)-(Qin*dt/43560)) > 0.0001){
x<-x+1
#Check the conditional statement in the while loop to break the loop before computation
if (x>500){
Sn<-S0
riser_flow<-Qin
break
}
if (abs((Sn-S0+riser_flow*dt/43560)-(Qin*dt/43560)) > 0.0001){
#If tolerance has not been achieved, use the bisection method to find S and Q
Sn<-(S1+Si)/2#New storage computed from the midpoint of max and min storage, S1 and Si respectivley
riser_flow<-Solver(Sn)#Corresponding outflow
#Now that flow has been calculated, the bisection method can be continued. Need to shorten interval with guess Sn
#Compute the MPM equation for S1 (maximum storage) and Sn (current iterator). If product is negative, they are of
#opposite sign. Thus, a solution for S and Q are contained within this new interval, replace Si with Sn. Otherwise,
#if they are of the same sign, assign Sn as S1 to serve as the new maximum storage value. Then replace riserP with
#the current riser_flow for future reference in solving the MPM for S1
if(((Sn-S0+riser_flow*dt/43560)-(Qin*dt/43560))*((S1-S0+riserP*dt/43560)-(Qin*dt/43560))<0){
Si<-Sn
} else {
S1<-Sn
riserP<-riser_flow
}
} else {
#Tolerance achieved, solution found
break
}
}
#Store stage, storage, and outflow calculated from the MPM method for plotting
dat$MPMStorage[i]<-Sn
dat$MPMQout[i]<-riser_flow
dat$MPMStage[i]<-approx(x=SS$Storage,y=SS$Stage,xout=S1,rule=1)$y
dat$its[i]<-x
}
par(mar=c(5,6,2,4))
plot(
as.POSIXct(dat$timestamp),
as.numeric(dat$MPMStage),
type='l',
col='blue',
lwd=2,
cex.lab=2,
cex.axis=2,
#ylim=c(0,200),
xlab='Time',
ylab='Stage (ft)',
ylim=c(min(dat$impoundment_lake_elev),max(dat$impoundment_lake_elev))
)
lines(
as.POSIXct(dat$timestamp),
dat$impoundment_lake_elev,
col='red',
lwd=2,
type='l'
)
points(as.POSIXct(dat$timestamp[dat$impoundment_its>500&dat$impoundment_riser_head>0]),dat$impoundment_lake_elev[dat$impoundment_its>500&dat$impoundment_riser_head>0])
par(new=T)
plot(dat$timestamp,dat$impoundment_Qin,type='l',lty=3,ann=F,axes=F)
